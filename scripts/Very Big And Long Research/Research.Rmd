---
title: "Опрос программистов"
author: "Penza Street Analitics"
output:
  html_document:
    background: '#161a1e'
    highlight: tango
    theme: spacelab
    toc: yes
    toc_float:
      collapsed: no
      smooth_scroll: yes
  word_document:
    toc: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, cache = TRUE)
library(ggplot2)
library(ggthemes)
library(readxl)
library(extrafont)
font_import()
loadfonts(device = "win")
opros <- read_xlsx("ProgOprosEdited.xlsx")
```

# Вступление

Для того, чтобы создавать какое-либо системное или прикладное программное обеспечение,
следует изучить целевую аудиторию потенциального продукта и интересы его возможных
потребителей.

*Penza Street* заинтересована в создании инструментов, помогающих программистам,
поэтому решила провести опрос среди программистов и попытаться понять, что это
за люди, и чего они хотят.

Результаты исследования представлены ниже. Не все результаты были правильно и грамотно
интерпретированы, так как сама структура опроса обладана массой изъянов. Компания
*Penza Street* не рискнула проводить второй, более качественный опрос во избежание
утери доверия среди целевой аудитории.

О серьёзности некоторых выводов говорить не приходится, поэтому, надеемся, вам
понравится количество юмора в статье, ибо некоторые закономерности представляют из себя
откровенный бред (*Но, статистически вероятный бред*).

## От автора

*Penza Street Analitics* - дочерняя организация от *Penza Street Company*, уникальной
в своём роде компании. В чём её уникальность? Хотя бы в том, что все возможные
должности в ней занимает один человек, а сама компания не закреплена ни одним правовым
актом ни одной страны мира.

Так что, дорогие читатели. [*Павел Соломатин*](https://vk.com/crave_ozer_man), приятно познакомиться.

# История данных

Данные, использующиеся в опросе, были собраны за август 2019 года. В данных хранятся
сведения о `r nrow(opros)` программистах.

[Опрос](https://forms.yandex.ru/u/5d4336b07effdd03528c193c/) 
является до сих пор открытым, можете заполнить анкету. Это очень поможет
~~(смех из-под стола)~~.

Программисты по себе люди замкнутые и большинстве своём разрозненные личности.
Собрать их в одном месте было нелегко. Если вам когда-то повезло пройти этот опрос,
то скорее всего вы относились к этим категориям людей:

1. Выпускники Яндекс.Лицея 2019 года, которые были в офисе Яндекса на выпускном. 
(автор и сам таким является)
2. Участники летней смены образовательного центра "Сириус" 
(отдельная благодарность [*Алексею Медведеву*](https://vk.com/medal99) за помощь
в сборе данных)
3. Программисты Пензы, которые каким-либо образом знакомы с автором статьи.

# Математический аппарат исследования

> Кто считает себя бородатым гуру статистики или просто не хочет вникать в вот это
вот всё, может смело пропустить этот раздел.

Математика - это всегда не просто, поэтому начнём издалека.

В основе исследования лежит статистика как наука в её чистом виде. Субъекты исследования - программисты. Объект исследования - предпочтения и навыки 
программистов и прочих посетителей опроса в мире информационных технологий.
В данном случае, ответы - это свойства объектов, то есть опрошенных.

Любые критерии могут быть разделены на качественные и количественные. Большинство
критериев в опросе было качественными, так как не было вопросов в стиле "оцените
это по шкале от 1 до 10". В это тоже есть минус опроса - нельзя ответить на вопрос
"сколько?". Качественные признаки ещё называют номинативными.

Однако, статистика на то и наука, что умеет много чего. Например:

*Для одной переменной*:

1. Если она качественная, проверить её на равномерность распределения (в каждой
группе элементы встречаются одинаково часто)
2. Если она количественная, проверить её на нормальность распределения (особый вид
распределения, выглядит как-то так)
![Нормальное распределение](normal_distribution.gif)
За первый пункт отвечает 
[Критерий Хи-квадрат](https://en.wikipedia.org/wiki/Chi-squared_test),
а за второй 
[Тест Шапиро-Уилка](https://en.wikipedia.org/wiki/Shapiro%E2%80%93Wilk_test).

> Правда, как оказалось, данные вышли далеко не равномерные и не нормальные.
Но статистика и это может обойти

*Для двух переменных*:

1. Если обе качественные, то проверить их на связанность, или *корреляцию*.
2. Если одна качественная, а другая количественная, то проверить различие количественного
признака при разбиении на группы.
3. Если обе качественные, то проверить на пропорциональность групп по двум признакам.

За первый пункт отвечает [Коэфиициент корреляции Пирсона](https://en.wikipedia.org/wiki/Pearson_correlation_coefficient),
за второй - [Дисперсионный анализ](https://en.wikipedia.org/wiki/Analysis_of_variance),
а за третий - [Точный тест Фишера](https://en.wikipedia.org/wiki/Fisher%27s_exact_test)

> Правда, все первые два теста требуют "нормальности" данных, которой в этих данных нет.

Поэтому существуют их непараметрические аналоги:

1. [Коэффициент корреляции Кендала](https://en.wikipedia.org/wiki/Kendall_rank_correlation_coefficient)
2. [Тест Краскела-Уоллиса](https://en.wikipedia.org/wiki/Kruskal%E2%80%93Wallis_one-way_analysis_of_variance)

При визуализации данных будут использованы два вида графиков:

1. [Столбчатая гистограмма](https://en.wikipedia.org/wiki/Bar_chart)
![Гистограмма](Histogram.jpg)
2. [Диаграмма рассеяния](https://en.wikipedia.org/wiki/Scatter_plot)
![Диаграмма рассеяния](density_diagram.png)

# Программное обеспечение, использованное в исследовании

> Кто не хочет вникать в то, что такое R, и как было реализовано это исследование, может
смело пропускать этот раздел.

## Ссылки на программное обеспечение

В исследовании был использован язык программирования [**R**](https://www.r-project.org/)
версии `r getRversion()`.

Готовый файл статьи был получен с помощью пакета [RMarkdown](https://rmarkdown.rstudio.com)

Для визуализации был использован пакет [ggplot2](https://ggplot2.tidyverse.org/),
а также [ggthemes](https://CRAN.R-project.org/package=ggthemes). Для отображения
красивых шрифтов на графиках был использован пакет
[extrafont](https://CRAN.R-project.org/package=extrafont)

Для загрузки и выгрузки данных через формат .xlsx были использованы библиотеки
[readxl](https://CRAN.R-project.org/package=readxl) и
[writexl](https://CRAN.R-project.org/package=writexl)

## Код исследования

Дабы не грузить читателей кодовыми вставками, весь код исследования будет записан 
в одном месте - здесь.

Полную версию кода исследования можно увидеть на
[GitHub](https://github.com/PenzaStreetGames/ProgOpros)

```{r echo=TRUE, warning=FALSE, message=FALSE, cache=TRUE}
# rm(list = ls())
options(stringsAsFactors = TRUE)
library(readxl)
library(dplyr)
opros <- read_excel("ProgOprosEdited.xlsx")
opros <- select(opros, -number) # колонка номеров не нужна

# Функция, преобразующая набор строк в фактор (словарь)
factorise <- function(opros) {
  factoring_cols <-
    c(
      "gender",
      "status",
      "processor",
      "microboard",
      "desctop_os",
      "mobile_os",
      "editor_theme",
      "cycle_recursion",
      "cycle",
      "java_kotlin",
      "zero_division",
      "indexing",
      "typing",
      "slow_python",
      "list_mutable",
      "sugar",
      "list_expressions",
      "ternar_module",
      "patterns",
      "mobile_desctop",
      "web",
      "back_front_end",
      "flask_django",
      "python",
      "cpp",
      "javascript",
      "pascal",
      "csharp",
      "java",
      "c",
      "php",
      "kotlin",
      "lua",
      "scratch",
      "basic",
      "go",
      "ruby",
      "fasm",
      "bf",
      "haskel",
      "pycharm",
      "vscode",
      "idle",
      "notepad",
      "notepadpp",
      "wing",
      "sublime",
      "jupiter",
      "atom",
      "console",
      "machine_learning",
      "big_data",
      "metaprog",
      "quantum",
      "cryptography",
      "math"
    )
  colnames(opros)
  for (string in factoring_cols) {
    # print(string)
    opros[[string]] <- factor(opros[[string]])
  }
  
  return(opros)
}
df_struct <- list() # список, хранящий данные о структуре данных
df_struct$numeric_vars <- # список количественных переменных
  c(
    "languages_number",
    "editors_number",
    "future_number",
    "humour",
    "other_opinion",
    "sugar_using",
    "python_discontent",
    "middle_answers",
    "dont_know",
    "web_using",
    "apple"
  )
df_struct$quality_vars <- # список качественных переменных
  c(
    "gender",
    "status",
    "processor",
    "microboard",
    "desctop_os",
    "mobile_os",
    "editor_theme",
    "cycle_recursion",
    "cycle",
    "java_kotlin",
    "zero_division",
    "indexing",
    "typing",
    "slow_python",
    "list_mutable",
    "sugar",
    "list_expressions",
    "ternar_module",
    "patterns",
    "mobile_desctop",
    "web",
    "back_front_end",
    "flask_django",
    "python",
    "cpp",
    "javascript",
    "pascal",
    "csharp",
    "java",
    "c",
    "php",
    "kotlin",
    "lua",
    "scratch",
    "basic",
    "go",
    "ruby",
    "fasm",
    "bf",
    "haskel",
    "pycharm",
    "vscode",
    "idle",
    "notepad",
    "notepadpp",
    "wing",
    "sublime",
    "jupiter",
    "atom",
    "console",
    "machine_learning",
    "big_data",
    "metaprog",
    "quantum",
    "cryptography",
    "math"
  )
df_struct$vars <- colnames(opros) # список всех переменных
df_struct$simple_vars <- # список логически полных переменных
  c(
    "gender",
    "status",
    "processor",
    "microboard",
    "desctop_os",
    "mobile_os",
    "editor_theme",
    "cycle_recursion",
    "cycle",
    "java_kotlin",
    "zero_division",
    "indexing",
    "typing",
    "slow_python",
    "list_mutable",
    "sugar",
    "list_expressions",
    "ternar_module",
    "patterns",
    "mobile_desctop",
    "web",
    "back_front_end",
    "flask_django",
    "languages_number",
    "editors_number",
    "future_number",
    "humour",
    "other_opinion",
    "sugar_using",
    "python_discontent",
    "middle_answers",
    "dont_know",
    "web_using",
    "apple"
  )
df_struct$complex_vars <- # список сгруппированных переменных
  list(
    languages = c(
      "python",
      "cpp",
      "javascript",
      "pascal",
      "csharp",
      "java",
      "c",
      "php",
      "kotlin",
      "lua",
      "scratch",
      "basic",
      "go",
      "ruby",
      "fasm",
      "bf",
      "haskel"
    ),
    editors = c(
      "pycharm",
      "vscode",
      "idle",
      "notepad",
      "notepadpp",
      "wing",
      "sublime",
      "jupiter",
      "atom",
      "console"
    ),
    futures = c(
      "machine_learning",
      "big_data",
      "metaprog",
      "quantum",
      "cryptography",
      "math"
    )
  )
result <- list() # список для хранения промежуточных и итоговых результатов

opros <- factorise(opros) # факторизация всех сторковых столбцов
# str(opros)

## Стадия 1. Простая предобработка и гипотезы

# Simple tables
result$simple_tables <- apply(opros, 2, function(x) 
  round(prop.table(table(x)), digits = 3))

# Simple Fisher Test
result$simple_fisher_test <- apply(opros, 2, function(x)
  chisq.test(table(x)))

# Shapiro Test
result$shapiro_test <- lapply(opros[df_struct$numeric_vars], 
                              function(x) shapiro.test(x))

## Стадия 2. Двойные таблицы и взаимосвязи

# Double tables
result$double_tables <- lapply(opros, function(x)
  lapply(opros, function(y) round(prop.table(table(x, y)), digits = 3)))

# Check equals
# sapply(opros, function(x) 
#  sum(sapply(opros, function(y) all(as.vector(x) == as.vector(y)))))
# all rigth

# Double Fisher Test
result$double_fisher_test <- lapply(opros[df_struct$quality_vars], function(x) 
  lapply(opros[df_struct$quality_vars][sapply(opros[df_struct$quality_vars], function(z) !all(as.vector(x) == as.vector(z)))], 
         function(y) fisher.test(table(x, y), simulate.p.value = T)))

# Cor test Kendall
result$cor_test_kendal <- lapply(opros[df_struct$numeric_vars], function(x) 
  lapply(opros[df_struct$numeric_vars]
         [sapply(opros[df_struct$numeric_vars], function(z) !all(as.vector(x) == as.vector(z)))],
         function(y) cor.test(x, y, method = "kendall")))

# Kruskal test
result$kruskal_test <- lapply(opros[df_struct$numeric_vars], function(x)
  lapply(opros[df_struct$quality_vars], function(y)
    kruskal.test(x, y)))

## Исследование взаимосвязей

# Researching edges
get_edges <- function(data, level) {
  df <- data.frame(x = c(), y = c(), p = c())
  lapply(names(data), function(x)
    lapply(names(data[[x]]), function(y) 
    { 
      if (data[[x]][[y]]$p.value < level) 
        if (!(paste(x, y) %in% c(apply(df, 1, function(x) paste(x["x"], x["y"])),
                                 apply(df, 1, function(x) paste(x["y"], x["x"])))))
          df <<- rbind(df, data.frame(x = x, y = y, p = data[[x]][[y]]$p.value)) 
    }
    ))
  df <- df[df$p < level,]
  df$p_log <- abs(round(log(df$p, base = 10)))
  df
}

# Removing obvious edges in Kruskal test
remove_obvious_edges <- function(data) {
  obvious_edges <- list(
    humour = c("gender", "status", "editor_theme"),
    other_opinion = c("zero_division", "indexing", "typing"),
    python_discontent = c("slow_python", "list_mutable", "sugar"),
    sugar_using = c("list_expressions", "ternar_module", "patterns"),
    apple = c("mobile_os", "desctop_os"),
    dont_know = c("microboard", "list_expressions", "ternar_module", "patterns", "flask_django"),
    web_using = c("web", "flask_django"),
    middle_answers = c("processor", "desctop_os", "mobile_os", "cycle_recursion", 
                       "cycle", "java_kotlin", "slow_python", "list_mutable", "sugar",
                       "mobile_desctop", "flask_django"),
    languages_number = c("python", "cpp",
                         "javascript", "pascal", "csharp", "java", "c",
                         "php", "kotlin", "lua", "scratch", "basic",
                         "go", "ruby", "fasm", "bf", "haskel"),
    editors_number = c("pycharm", "vscode", "idle", "notepad",
                       "notepadpp", "wing", "sublime", "jupiter",
                       "atom", "console"),
    future_number = c("machine_learning", "big_data", "metaprog",
                      "quantum", "cryptography", "math")
  )
  answer <- data.frame(x = c(), y = c(), p = c(), p_log = c())
  apply(result$important_edges$kruskal_test, 1, function(x) {
    if (!(x[["x"]] %in% names(obvious_edges) & 
          any(sapply(unlist(obvious_edges[as.vector(x[["x"]])]), function(z) as.vector(x[["y"]]) == z)))) {
      answer <<- rbind(answer, data.frame(x = c(x["x"]), y = c(x["y"]), 
                                          p = c(x["p"]), p_log = c(x["p_log"])))
    }
  })
  row.names(answer) <- NULL
  answer
}

get_all_edges <- function(level) {
  result$important_edges$cor_test <<- get_edges(result$cor_test_kendal, level)
  result$important_edges$fisher_test <<- get_edges(result$double_fisher_test, level)
  result$important_edges$kruskal_test <<- get_edges(result$kruskal_test, level)
  result$important_edges$kruskal_test <<- remove_obvious_edges(result$important_edges$kruskal_test)
  
  # Uniting edges
  result$important_edges$all <<- rbind(result$important_edges$fisher_test, result$important_edges$cor_test,
                                       result$important_edges$kruskal_test)
  result$important_edges$all$x <<- as.character(result$important_edges$all$x)
  result$important_edges$all$y <<- as.character(result$important_edges$all$y)
  result$important_edges$all$p <<- as.numeric(result$important_edges$all$p)
  result$important_edges$all$p_log <<- as.numeric(result$important_edges$all$p_log)
  result$important_edges$all
}
result$important_edges$all <- get_all_edges(0.05)

find_opros_col <- function(x) {
  names(opros)[sapply(names(opros), function(y) all(as.vector(opros[[y]]) == as.vector(x)))]
}

# str(result$important_edges$all)
result$edged_vars <- lapply(opros, function(x) {
  x <- find_opros_col(x)
  r <- apply(result$important_edges$all[
    apply(result$important_edges$all, 1, function(y)
      y["x"] == x | y["y"] == x),], 1, function(y) {
        ifelse(y["x"] == x, y["y"], y["x"])
      })
  names(r) <- NULL
  r})
# result$edged_vars

result$edged_vars_list <- data.frame(var = df_struct$vars, 
                                     edged_vars = sapply(opros, function(x) {
                                       x <- find_opros_col(x)
                                       paste(result$edged_vars[[x]], collapse = " ")
                                     }))

var_labels <- c(gender = "Пол",
                status = "Социальный\nстатус",
                languages_number = "Количество используемых языков",
                editors_number = "Количество используемых редакторов",   
                future_number = "Количество выбранных перспективных отраслей",
                humour = "Коэффциент юмора",
                other_opinion = "Коэффициент другого мнения",
                python_discontent = "Коэффициент недовольства питоном",
                sugar_using = "Коэффициент использования синтаксического сахара",
                middle_answers = "Коэффициент лояльности ответов",
                dont_know = "Коэффициент незнания",
                web_using = "Коэффициент использования web'а",     
                apple = "Коэффициент лояльности к Apple",
                processor = "Выбор процессора",
                microboard = "Выбор микроплаты",
                desctop_os = "Выбор\nнастольной ОС",
                mobile_os = "Выбор\nмобильной ОС",
                editor_theme = "Выбор\nтемы редактора",
                cycle_recursion = "Цикл\nили\nрекурсия",
                cycle = "Выбор\nвида цикла",
                java_kotlin = "Java\nили\nKotlin",
                zero_division = "Мнение\nо делении\nна ноль",
                indexing = "Выбор индексации",
                typing = "Сколько будет\n1 + \"а\"",           
                slow_python = "Мнение\nо скорости\nпитона",
                list_mutable = "Отношение\nк изменяемости\nсписков в питоне",
                sugar = "Мнение\nо \"сахарности\"\nпитона",
                list_expressions = "Использование\nсписочных\nвыражений",
                ternar_module = "Использование\nтернарного\nмодуля",
                patterns = "Использование\nшаблонов\nпроектирования",
                mobile_desctop = "Мобильная\nразработка\nили\nдесктоп",
                web = "Необходимость\nвеба",           
                back_front_end = "Предпочитаемая\nотрасль\nвеба",
                flask_django = "Flask\nили\nDjango",
                python = "Использование\nPython",
                cpp = "Использование\nC++",        
                javascript = "Использование\nJavaScript",
                pascal = "Использование\nPascal",
                csharp = "Использование\nC#",
                java = "Использование\nJava",
                c = "Использование\nC",
                php = "Использование\nPHP",
                kotlin = "Использование\nKotlin",
                lua = "Использование\nLua",      
                scratch = "Использование\nScratch",
                basic = "Использование\nBasic",
                go = "Использование\nGo",
                ruby = "Использование\nRuby",
                fasm = "Использование\nFASM",
                bf = "Использование\nBrainfuck",
                haskel = "Использование\nHaskel",
                pycharm = "Использование\nPyCharm",
                vscode = "Использование\nVisual Studio\nCode",
                idle = "Использование\nIDLE",
                notepad = "Использование\nБлокнота",
                notepadpp = "Использование\nNotepad++",
                wing = "Использование\nWing",
                sublime = "Использование\nSublime Text",
                jupiter = "Использование\nJupiter\nNotebook",
                atom = "Использование\nAtom", 
                console = "Использование\nконсоли",
                machine_learning = "Ожидание\nразвития\nмашинного\nобучения",
                big_data = "Ожидание\nразвития\nбольших\nданных",
                metaprog = "Ожидание\nразвития\nметапрограммирования",        
                quantum = "Ожидание\nразвития\nквантовой\nлогики",
                cryptography = "Ожидание\nразвития\nкриптографии",
                math = "Ожидание\nразвития\nприкладной\nматематики")
spaced_var_labels <- sapply(var_labels, function(x) gsub("\n", " ", x))
full_var_labels <- c(
  python = "01. Python",
  cpp = "02. C++",        
  javascript = "03. JavaScript",
  pascal = "04. Pascal",
  csharp = "05. C#",
  java = "06. Java",
  c = "07. C",
  php = "08. PHP",
  kotlin = "09. Kotlin",
  lua = "10. Lua",      
  scratch = "11. Scratch",
  basic = "12. Basic",
  go = "13. Go",
  ruby = "14. Ruby",
  fasm = "15. FASM",
  bf = "16. Brainfuck",
  haskel = "17. Haskel",
  pycharm = "01. PyCharm",
  vscode = "02. Visual Studio\nCode",
  idle = "03. IDLE",
  notepad = "04. Блокнот",
  notepadpp = "05. Notepad++",
  wing = "06. Wing",
  sublime = "07. Sublime\nText",
  jupiter = "08. Jupiter\nNotebook",
  atom = "09. Atom", 
  console = "10. Консоль",
  machine_learning = "01. Машинное\nобучение",
  big_data = "02. Большие\nданные",
  metaprog = "03. Метапрограммирование",        
  quantum = "04. Квантовая\nлогика",
  cryptography = "05. Криптография",
  math = "06. Прикладная\nматематика"
)
var_positive_flags <- c(
  languages = "Использует",
  editors = "Использует",
  futures = "Ожидает"
)
complex_var_labels <- c(
  languages = "Популярность\nязыков\nпрограммирования",
  editors = "Популярность\nредакторов\nкода",
  futures = "Популярность\nвозможных\nпередовых\nотраслей"
)
spaced_complex_var_labels <- sapply(complex_var_labels, function(x) gsub("\n", " ", x))

## Отрисовка графиков

library(ggplot2)
library(extrafont)
loadfonts(device = "win")

theme_pablo <- theme(panel.background = element_rect(fill = "grey70"), 
                     plot.background = element_rect(fill = "grey60"),
                     legend.background = element_rect(fill = "grey80"),
                     text = element_text(family = "Comic Sans MS"),
                     axis.text.x = element_text(angle = 30, hjust = 1))

draw_plot <- function(x, y) {
  if (x %in% df_struct$numeric_vars & y %in% df_struct$numeric_vars) {
    random_colors <- colors()[sample(1:length(colors()), size = 2, replace = F)]
    plt <- ggplot(opros, aes(x = opros[[x]], y = opros[[y]], 
                             size = I(5), color = I(random_colors[1])))+
      geom_smooth(method = "lm", se = F, color = I(random_colors[2]), size = I(3))+
      geom_point()+
      scale_x_continuous(breaks = seq(1:10))+
      geom_jitter()+
      xlab(spaced_var_labels[x])+
      ylab(spaced_var_labels[y])+
      ggtitle(paste("Взаимосвязь переменных\n", spaced_var_labels[x], "и",
                    spaced_var_labels[y]))+
      theme_pablo
  }
  else if (x %in% df_struct$numeric_vars & y %in% df_struct$quality_vars) {
    plt <- ggplot(opros, aes(x = opros[[x]], fill = opros[[y]], color = I("black")))+
      geom_histogram(alpha = 0.8, binwidth = 1)+
      facet_wrap(~ opros[[y]], nrow = 3)+
      xlab(spaced_var_labels[x])+
      ylab("Частота")+
      ggtitle(paste("Взаимосвязь переменных\n", spaced_var_labels[x], "и",
                    spaced_var_labels[y]))+
      scale_fill_brewer(name = var_labels[y],
                        type = "qual", palette = sample(1:8, size=1))+
      scale_x_continuous(breaks = seq(1:10))+
      theme_pablo
  }
  else if (x %in% df_struct$quality_vars & y %in% df_struct$numeric_vars) {
    plt <- ggplot(opros, aes(x = opros[[y]], fill = opros[[x]], color = I("black")))+
      geom_histogram(alpha = 0.8, binwidth = 1)+
      facet_wrap(~ opros[[x]], nrow = 3)+
      xlab(spaced_var_labels[y])+
      ylab("Количество")+
      ggtitle(paste("Взаимосвязь переменных\n", spaced_var_labels[x], "и",
                    spaced_var_labels[y]))+
      scale_fill_brewer(name = var_labels[x],
                        type = "qual", palette = sample(1:8, size=1))+
      scale_x_continuous(breaks = seq(1:10))+
      theme_pablo
  }
  else if (x %in% df_struct$quality_vars & y %in% df_struct$quality_vars){
    plt <- ggplot(opros, aes(x = opros[[x]], fill = opros[[y]], color = I("black")))+
      geom_histogram(stat = "count")+
      facet_wrap(~ opros[[y]])+
      xlab(spaced_var_labels[x])+
      ylab("Количество")+
      ggtitle(paste("Взаимосвязь переменных\n", spaced_var_labels[x], "и",
                    spaced_var_labels[y]))+
      scale_fill_brewer(name = var_labels[y],
                        type = "qual", palette = sample(1:8, size=1))+
      theme_pablo
  }
  plt
}
draw_simple_plot <- function(x) {
  if (x %in% df_struct$quality_vars) {
    plt <- ggplot(opros, aes(x = opros[[x]], fill = opros[[x]], color = I("black")))+
      geom_histogram(stat = "count")+
      xlab(spaced_var_labels[x])+
      ylab("Количество")+
      ggtitle(paste("Распределение переменой\n", spaced_var_labels[x]))+
      scale_fill_brewer(name = var_labels[x],
                        type = "qual", palette = sample(1:8, size=1))+
      theme_pablo
  }
  else if (x %in% df_struct$numeric_vars) {
    random_color <- colors()[sample(1:length(colors()), size=1)]
    plt <- ggplot(opros, aes(x = opros[[x]], fill = I(random_color), color = I("black")))+
      geom_histogram(stat = "count")+
      xlab(spaced_var_labels[x])+
      ylab("Частота")+
      ggtitle(paste("Распределение переменной\n", spaced_var_labels[x]))+
      scale_fill_brewer(name = gsub(" ", "\n", var_labels[x]),
                        type = "qual", palette = sample(1:8, size=1), 
                        guide="colourbar")+
      scale_x_continuous(breaks = seq(1:10))+
      theme_pablo
  }
  plt
}
result$simple_plots <- lapply(opros, function(x) {
  x <- find_opros_col(x)
  plt <- draw_simple_plot(x)
  plt
})

draw_complex_plot <- function(x) {
  kit <- c()
  for (i in 1:length(unlist(df_struct$complex_vars[x]))) {
    y <- unlist(df_struct$complex_vars[x])[i]
    kit <- c(kit, 
             ifelse(opros[y] == var_positive_flags[x], full_var_labels[y], "none"))
  }
  kit <- data.frame(var = kit[kit != "none"])
  kit$var <- factor(kit$var)
  plt <- ggplot(kit, aes(x = var, fill = var, col = I("black")))+
    geom_histogram(stat = "count")+
    ggtitle(spaced_complex_var_labels[x])+
    xlab(spaced_complex_var_labels[x])+
    ylab("Частота")+
    scale_fill_brewer(name = "Частота",
                      type = "qual", palette = 3)+
    theme_pablo
  plt
}

result$complex_plots <- list()
result$complex_plots$languages <- draw_complex_plot("languages")
result$complex_plots$editors <- draw_complex_plot("editors")
result$complex_plots$futures <- draw_complex_plot("futures")

# gsub(" ", "_", gsub("\n ", "-", draw_plot("gender", "status")$labels$title))
# result$edged_vars
df <- data.frame(x = c(), y = c())
result$important_plots <- lapply(opros, function(x) {
  x <- find_opros_col(x)
  lapply(opros[unlist(result$edged_vars[x])], function(y) {
    y <- find_opros_col(y)
    plt <- draw_plot(x, y)
#      if (!(paste(x, y) %in% c(apply(df, 1, function(x) paste(x["x"], x["y"])),
#                             apply(df, 1, function(x) paste(x["y"], x["x"]))))) {
#      df <<- rbind(df, data.frame(x = x, y = y))
#      i <- gsub("\"", "", gsub(" ", "_", gsub("\n ", "-", plt$labels$title)))
#      ggsave(file = paste0(getwd(), "/plots/important_plots/", i, ".png"), 
#             plot = plt, device = "png")}
    plt})})

# Graph creating
library(igraph)
net <- list()
net$edges <- data.frame(from = result$important_edges$all$x,
                        to = result$important_edges$all$y,
                        weight = result$important_edges$all$p_log)
net$vertices <- data.frame(
  id = colnames(opros),
  type = ifelse(colnames(opros) %in% df_struct$numeric_vars, "numeric", "quality"))
graph <- graph.data.frame(net$edges, net$vertices, directed = F)
V(graph)$color <- ifelse(net$vertices$id %in% df_struct$numeric_vars, "orange", "skyblue")
E(graph)$width <- as.numeric(as.vector(net$edges$weight))
l <- layout.kamada.kawai(graph)
# result$egdes_graph <- plot(graph, layout= l, vertex.size = 15)

```

# Данные

## Ссылка

Используемые в опросе данные в предобработанном виде можно скачать по 
[ссылке](https://yadi.sk/i/WmRRsDzbnQ9H-g)

Для полноценной работы скрипта исследования следует скопировать файл данных в ту
же директорию, что и файл *Research.Rmd*.

## Структура данных

Всего в данных содержится `r length(colnames(opros))` признаков о 
`r length(rownames(opros))` программистах

> Быстро понять структуру данных можно, ознакомившись с 
[опросом](https://forms.yandex.ru/u/5d4336b07effdd03528c193c/)

> Рядом с переменной курсивом приведено её название в данных

### Качественные переменные

#### Общие признаки
- Пол *gender* 
  - Мужской
  - Женский
  - Кафельный (*пол не уточнён*)
- Социальный статус *status*
  - Школьник
  - Студент
  - Работяга (трудоустроенный программист)
  - Фрилансер (программист, работающий на заказ)
  - Аутсорсер (внештатный программист)
  - Пенсионер (*наличие пенсионеров в данных весьма странно - IT рынок России не настолько стар*)

#### Железо
- Предпочитаемая марка процессора *processor*
  - Intel
  - AMD
  - Всё равно
- Выбор микроплаты *microboard*
  - Arduino
  - Raspberry Pi
  - Не, не слышал

#### Программное обеспечение
- Предпочитаемая настольная ОС *desctop_os*
  - Windows
  - Linux
  - MacOS
  - Лишь бы был комп
- Предпочитаемая мобильная ОС *mobile_os*
  - Android
  - iOS
  - Лишь бы был телефон
- Тема редактора кода *editor_theme*
  - Светлая
  - Тёмная
  - Не фильтрованная (*тест на выявление алкопрогеров*)

#### Общепрограммистские вопросы
- Цикл или рекурсия? *cycle_recursion* (*варианты ответа очевидны, имеется средний ответ*)
- For или While? *cycle*
- Java или Kotlin? *java_kotlin*
- Мнение о делении на ноль *zero_division*
  - Ошибка
  - Так нельзя делать
  - Бесконечность
- Выбор индексации *indexing*
  - С нуля
  - С единицы
  - С произвольного числа
- Сколько будет 1 + "а"? *typing*
  - Ошибка типа
  - "1а"
  - 98 (то есть 1 + utf8 код символа "a")

#### Вопросы о питоне
- Мнение о скорости питона *slow_python*
  - Нормально
  - Терпимо
  - Побыстрее бы
- Отношение к изменяемости списков *list_mutable*
  - Позитивное
  - Нейтральное
  - Негативное
- Мнение о "сахарности" питона *sugar*
  - Слишком много сахара
  - Достаточно
  - Можно было послаще

#### Вопросы о использовании синтаскического сахара
- Использование тернарного модуля *ternar_module*
  - Не знал
  - Не использую
  - Редко
  - Часто
- Использование списочных выражений *list_expressions* (*ответы такие же*)
- Использование шаблонов проетирования *patterns*
  - Не знал о них
  - В питоне неприменимы
  - Редко
  - Часто
  
#### Вопросы о сферах программирования
- Мобильная или десктоп разработка? *mobile_desctop*
- Использование веба *web*
  - Нет
  - Как прилагающееся
  - Конечно
- Бек или фронт энд? *back_front_end*
  - Бек-энд
  - Фронт-энд
  - Фул-стек
- Flask или Django? *flask_django*
  - Flask
  - Django
  - Не знаю
  - Оба потянут
  - Оба не тянут
  
#### Используемые языки

В опросе было рассмотрено 17 наиболее известных ЯП 
(Dart не выбрал никто, в данных его нет). Каждому языку в данных соответствует 
переменная с его названием:

*python*, *cpp*, *javascript*, *pascal*, *csharp*, *java*, *c*, *php*, *kotlin*, 
*lua*, *scratch*, *basic*, *go*, *ruby*, *fasm*, *bf*, *haskel*

В переменных хранятся значения "Использует" или "Не использует" в зависимости от ответа

#### Используемые редакторы
В опросе было рассмотрено 10 редакторов кода, предпочтительно для питона,
включая консоль. Каждому редактору в данных соответствует переменная с его названием:

*pycharm*, *vscode*, *idle*, *notepad*, *notepadpp*, *wing*, *sublime*, *jupiter*,
*atom*, *jupyter*

В переменных хранятся значения "Использует" или "Не использует" в зависимости от ответа

#### Перспективные направления
В качестве разгрузочного вопроса участникам опроса предлагалось ответить, какие
из отраслей IT являются, по их мнению, перспективными. Предлагалось
6 отраслей: большие данные, машинное обучение, квантовая логика, криптография,
метапрограммирование и прикладная математика:

*big_data*, *machine_learning*, *quantum*, *cryptography*, *metaprog*, *math*

В переменных хранятся значения "Ожидает" или "Не ожидает" в зависимости от ответа

### Количественные переменные

Самым большим инструментарием по обработке данных статистика имеет для количественных
переменных. Однако, структура опроса была такова, что очевидными количественными
переменными были всего 3. Ещё 8 были получены путём объединения качественных переменных.

#### По имеющимся данным

- Количество языков программирования, которое знает программист *languages_number*
- Количество редакторов, используемых программистом *editors_number*
- Количество перспективных отраслей, которое видит программист *future_number*

#### Синтезированные из качественных
Эти переменные обладают относительной шкалой от 0 до 10.

- Чувство юмора (или маргинальность) *humour*
  - Ответы про пенсионера, кафельный пол и нефильтрованную тему повышают условный
  показатель "юмора"
- Другое мнение *other_opinion*
  - Нестандартные ответы на вопросы об индексации, типизации и делении на ноль
  повышают условный показатель "другого мнения"
- Недовольство питоном *python_discontent*
  - Негативные ответы о возможностях питона повышают условный показатель 
  "недовольства питоном"
- Использование синтаксического сахара *suger_using*
  - Использование тернарного модуля, списочных выражений и шаблонов проектирования
  повышают условный показатель "использования сахара"
- Лояльность ответов *middle_answers*
  - Количество компромиссных ответов
- Коэффициент незнания *dont_know*
  - Количество ответов в духе "Не знаю"
- Использование веба *web_using*
  - Количество наиболее объемлющих ответов по тематике веба
- Лояльность к Apple *apple*
  - Предпочтение macOS и iOS прочим продуктам

Ответы на все вопросы анкеты были обязательны и в некоторых местах не имели
подходящего ответа, в этом есть минус опроса. Зато, в данных нет ни одного
пропущенного значения.

Кому нечего делать, может пересчитать количество упомянутых переменных :)

# Распределения ответов
В этом разделе представлены распределения всех переменных в графическом и 
табличном виде, к каждому из которых приложено возможное объяснение.

Не у всех переменных есть таблица распределения. Это сделано для того, чтобы
уменьшить кровотечение из ваших глаз при лицезрении дробных величин в качестве
групп разделения.

## Физическо-психологические характеристики опрошенных
### Пол
```{r} 
result$simple_plots$gender
knitr::kable(result$simple_tables$gender)
```
*Выводы*:

1. Статистика явно не на стороне феминисток. Доля женщин в исследованном сегменте
ИТ статистически значимо меньше, чем доля мужчин
2. Зато представители меньшинств могут ликовать. Прогеры очень толерантны к ним.

### Социальный статус
```{r} 
result$simple_plots$status
knitr::kable(result$simple_tables$status)
```
*Выводы*:

1. В данных прослеживается явная возрастная перекошенность в сторону молодых. Это
свойство именно этой выборки, а не программистов в целом. 
2. 1 человек знал, что такое "Аутсорсер", либо это рандомный клик.
3. Несмотря на "молодость" выборки, суммарная доля студентов, работяг и пенсионеров
близка к четверти. Автор не считает слишком мнительным ставить под сомнение статус
пенсионера у некоторых опрошенных.

### Чувство юмора (или маргинальность)
```{r} 
result$simple_plots$humour
```
*Примечание*:

Неоднозначность названия критерия объясняется тем, что высший балл достался бы 
тому, чьи ответы были бы "кафельный пол", "пенсионер" и "нефильтрованная тема".
Психология подсказывает три возможные причины таких ответов: 

1. Человек обладает чувством юмора 
2. Человек не хочет распростараняться о себе, т. е. он гик
3. Человек обладает больной психикой, т. е. он конченный маргинал

*Выводы*:

1. ~~Хорошо, что~~ В данных не попалось ни одного "пенсионера кафельного пола,
предпочитающего нефильтрованную тему". Это говорит о неокончательной 
маргинализации программистов.
2. Программисты очень ответственно относятся к заполнению самых абсурдных форм
и не находят юмор всегда уместным.

### Лояльность ответов
```{r} 
result$simple_plots$middle_answers
```
*Выводы*:

1. Большинство опрошенных дали среднее количество компромиссных ответов
2. Особо яростных и непримиримых идеалистов, оказалось немного
3. Около правой границы графика можно увидеть небольшое возмущение. Это мудрецы,
проникшиеся вселенской гармонией, ищущие истину не в пределах, а в середине.
Там также могли оказаться мямли и потенциальные политики.

### Коэффициент незнания
```{r} 
result$simple_plots$dont_know
```
*Примечание*:

Опрос не имел перед собой задачи оценить умственные способности программистов.
В качестве понятия знания здесь взято количество ответов, которые могли бы дать 
самые рассудительные сотрудники ИТ.

*Выводы*:

1. Количество "полных профанов" в программировании не так уж велико
2. Хотя, возможна ситуцаия, что правильные ответы просто навязаны взглядом 
большинства

### Количество перспективных отраслей, которое видит программист
```{r} 
result$simple_plots$future_number
knitr::kable(result$simple_tables$future_number)
```

*Выводы*:

1. Часть испытуемых тупо выбрала всё, что не есть хорошо
2. Оптимальное число возможных перспективных отраслей - 3

### Самые популярные возможные перспективные отрасли
```{r} 
result$complex_plots$futures
```
*Выводы*:

1. Абсолютное большинство горой стоит за то, что машинное обучение станет 
передовой отраслью. Страшным сном программистов мог бы стать искусственный
интеллект, пишуший программы.
2. Немного меньший процент опрошенных считает Биг Дату перспективной отраслью
3. Метапрограммирвование, квантовая логика и криптография обладают мнением
о перспективности меньше среднего.
4. Программисты не любят или не видят применение прикладной математики

## Железо
### Выбор процессора
```{r} 
result$simple_plots$processor
knitr::kable(result$simple_tables$processor)
```
*Выводы*:

1. Intel  пользуется большей популярностью в массах, нежели AMD
2. Одна пятая, которой "всё равно", либо является представителями буржуазии, 
у которых комп настолько прокачен, что тянет всё, либо это пожилые геймеры, которым
хватает игры [Super Mario Bros](https://supermariobros.io), которая, как известно, 
не так требовательна к ресурсам ПК.

### Выбор микроплаты
```{r} 
result$simple_plots$microboard
knitr::kable(result$simple_tables$microboard)
```
*Выводы*:

1. Отмечена высокая осведомлённость программистов в области "ручного железа"
2. Хотя сравнение микроконтроллера и одноплатного компьютера было не совсем логичным,
оно стало интересным индикатором знаний программиста (*см. ниже*)

## Программное обеспечение
### Предпочитаемая настольная ОС
```{r} 
result$simple_plots$desctop_os
knitr::kable(result$simple_tables$desctop_os)
```
*Выводы*:

1. Окна являются наиболее популяной ОС среди программистов, хотя Linux с его
армией дистрибутивов являются неплохим подспорьем майкрософтовской гегемонии.
2. Количество пользователей яблоко-компов допустимо невелико, однако миру приходится 
считаться с их существованием.

### Предпочитаемая мобильная ОС
```{r} 
result$simple_plots$mobile_os
knitr::kable(result$simple_tables$mobile_os)
```
*Выводы*:

1. Доля предпочтения андроида указывает на успешность социалистической 
революции и процветание пролетариата. Доля ~~буржуев~~ пользователей Apple 
в мобильном секторе значительно меньше.

### Лояльность к Apple
```{r} 
result$simple_plots$apple
```
*Выводы*:

1. Не так уж и много людей, полностью одобряющих яблочную продукцию
2. ~~Процентное отношение нелояльных к эпплу программистов в приближении равно
доле бедных людей в России.~~ На самом деле их (бедных) всего 12% :)
3. На основе этого распределния *далее* будет сделана интересная закономерность 

### Тема редактора кода
```{r} 
result$simple_plots$editor_theme
knitr::kable(result$simple_tables$editor_theme)
```
*Выводы*:

1. Программисты давно выбрали свою 
[сторону силы](https://ru.wikipedia.org/wiki/%D0%97%D0%B2%D1%91%D0%B7%D0%B4%D0%BD%D1%8B%D0%B5_%D0%B2%D0%BE%D0%B9%D0%BD%D1%8B).
2. Обнаружена массивная группа алконавтов - около 10% опрошенных.
3. Совет для тех, кто выбрал светлую тему: оглядывайтесь почаще.

### Количество редакторов, используемых программистом
```{r} 
result$simple_plots$editors_number
knitr::kable(result$simple_tables$editors_number)
```

*Примечания*:

1. Следует учитывать, что опрос проводился среди питонистов, и редакторы 
предлагались для питона. Возможно, на самом деле, используемых редакторов могло
быть больше.

*Выводы*:

1. Большинству для счастья много не надо
2. Все десять предложенных редакторов использовать никто не додумался

### Самые популярные редакторы
```{r} 
result$complex_plots$editors
```

*Примечания*:

1. Следует учитывать, что опрос проводился среди питонистов, и редакторы 
предлагались для питона. Возможно, есть и другие популярные редакторы.

*Выводы*:

1. С кратным отрывом среди питонистов более популярным является PyCharm.
Хвала компании JetBrains за качественное ПО, доступное не всегда по лицензионным
ключам.
2. Wing, активно предлагаемый студентам Яндекс.Лицея на первом году обучения
в общей массе не получил должного распространения.
3. IDLE, Блокнот и Notepad++, несмотря на небольшой фунционал (особенно у 
Блокнота) являются достаточно популярными.
4. Хоть VS Code является лишь редактором кода, а не средой разработки, он занял
второе место.
5. Sublime Text, Jupyter Notebook и Atom являются достаточно мощными 
инструментами, но не находящими достаточного одобрения информационного 
пролетриата
6. Нашлись извращенцы, которые кодят в консоли. Хотелось бы посмотреть на то, как
они пилят проекты.

## Общепрограммистские вопросы
### Количество языков программирования, которое знает программист
```{r} 
result$simple_plots$languages_number
knitr::kable(result$simple_tables$languages_number)
```

*Выводы*:

1. Оптимальное количество используемых языков - 2
2. Достаточно большие группы программистов встречаются вплоть до 7 языков
3. Лучший результат - 10 из 17 предложенных языков. Этот человек, либо машина,
либо кремлебот, ибо пропаганду приходится распространять на разных сайтах и платформах.

### Самые популярные языки программирования
```{r} 
result$complex_plots$languages
```
*Примечания*:

1. Вариант ответа "Pascal" появился не с самого начала опроса, поэтому, его 
реальная доля используемости может быть больше.
2. На все языки не хватило цветов палитры диаграммы. Это лишний раз подчёркивает
маловажность непопулярных вариатов.
3. Исследование написано на языке R, который даже не предлагался в опросе. Автор
исследования и сам не ожидал, что писать придётся на нём.

*Выводы*:

1. А что вы ещё ожидали, если опрос проводился среди питонистов. Однако,
не все `r nrow(opros)` опрошенных используют питон.
2. На втором месте по популярности идут плюсы, и делают это совершенно заслуженно.
Язык мощный, быстрый и всеобъемлющий.
3. Далее идёт JavaScript и старина Pascal. Первый знаменит веб-разработкой на нём,
а второй тем, что школьники всей нашей многонациональной, стремящейся быть
цифровой сверхдержавой, страны начинают знакомство с программированием именно
с этого 
[пятидесятилетнего деда](https://ru.wikipedia.org/wiki/%D0%9F%D0%B0%D1%81%D0%BA%D0%B0%D0%BB%D1%8C_(%D1%8F%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F))
4. Далее следуют C# (музыканты его ещё называют ре-бемоль) и Java. Как Микрософт
и Оракл не соревновались в создании языка на виртуальной машине, выиграть
расположение этого сектора прогеров у них не получилось.
5. Далее идут Си и PHP (в простонародье - пыха). Первый никогда не умрёт (если
только из-за плюсов), а второй до сих пор терроризирует всю интернет-безопасность
своими вставками в формы.
6. Kotlin оказался слишком молодым и незрелым, но у него есть все шансы занять
место джавы под солнцем.
7. Далее по популярности следуют Lua, Scratch и Basic. Автор не находит, ни слов
ни стереотипов о языке Lua, поэтому воздержится от комментария. 
Scracth - вот с чего надо начинать знакомство с программирвоанием - наглядно и 
просто. Что же касается Бейсика, то непонятно, почему этот современник Фортрана
до сих пор коптит небо и пачкает своими манускриптами листы ГИА.
8. Go чалится на дне топ-листа рядом с Ruby (он же оксид алюминия с примесью 
хрома), FASM (разновидность ассемблера) и Brainfuck (воздержусь от нецензурных
переводов и назову его "Вынос мозга", хотя это не передаёт всей его сущности)
9. Подпирает дно топ-листа функциональный язык Haskel. (no comments)

### Цикл или рекурсия?
```{r} 
result$simple_plots$cycle_recursion
knitr::kable(result$simple_tables$cycle_recursion)
```
*Выводы*:

1. Половина опрошенных прониклись вселенской мудростью и нашли оба подхода:
объектный и функциональный - применимыми в конкретных случаях.
2. Малый процент выбравших рекурсию можно объяснить тем, что многие так и не смогли
из неё выбраться.

### For или While?
```{r} 
result$simple_plots$cycle
knitr::kable(result$simple_tables$cycle)
```
*Выводы*:

1. Большинство опрошенных не застали времена ассемблера, поэтому сочли встроенную
переменную в цикле for более удобной.
2. Количество проникшихся вселенской мудростью по этому вопросу оказалось меньше,
по сравнению с прошлым вопросом.

### Java или Kotlin?
```{r} 
result$simple_plots$java_kotlin
knitr::kable(result$simple_tables$java_kotlin)
```
*Выводы*:

1. Это одна из немногих переменных, которая распределилась практически равномерно
2. Ровным счётом непонятно, что же лучше и как быть
3. Холиварная война по предпочтению java и kotlin могла бы привести к полной 
[аннигиляции](https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%BD%D0%B8%D0%B3%D0%B8%D0%BB%D1%8F%D1%86%D0%B8%D1%8F) 
программистов.

### Мнение о делении на ноль
```{r} 
result$simple_plots$zero_division
knitr::kable(result$simple_tables$zero_division)
```
*Выводы*:

1. Занудное большинство считает всё необычное и неоднозначное поломкой системы и
стремится во что бы то ни стало избегать таких ситуаций.
2. Сердце радуется за наличие среди прогеров этих 23% от общей массы, которые,
возможно, разбираются в пределах.
3. Юные [Пьеры Ланцели](https://ru.wikipedia.org/wiki/%D0%92%D0%B0%D0%BD%D1%86%D0%B5%D0%BB%D1%8C,_%D0%9F%D1%8C%D0%B5%D1%80_%D0%9B%D0%BE%D1%80%D0%B0%D0%BD) 
и ответвления большинства составляют около 12%.

### Выбор индексации
```{r} 
result$simple_plots$indexing
knitr::kable(result$simple_tables$indexing)
```
*Выводы*:

1. Программисты почти превратились в компьютеры, ибо разделяют их нумерацию с нуля.
2. Истинные мечтатели программирования и ярые революционеры знают, где трава зеленее

> Не во всех современных языках программирования нумерация начинается с нуля. 
Например в R нумерация начинается с единицы, а в Паскале ~~(кто-то назвал его 
современным :) )~~ - с произвольного числа. 

### Сколько будет 1 + "a"?
```{r} 
result$simple_plots$typing
knitr::kable(result$simple_tables$typing)
```
*Выводы*:

1. Большиство, вторя всяким питонам и джавам, говорит, что смешение типов невозможно.
2. Доля любителей слабой типизации достаточно велика.

### Другое мнение
```{r} 
result$simple_plots$other_opinion
```
*Примечание*:

1. Данный критерий оценивал количество ответов, несовпадающих с ответами 
большинства по спорным вопросам программирования (деление на ноль, индексирование 
и типизация)
2. Коэффииент и не носил бы другого названия, если бы большинство по этой шкале 
получило ноль.

*Выводы*:

1. Не нашлось ни одного, кто-бы получал бы ∞ при делении на ноль, индексировал
массивы с произвольного числа и получал 98 при сложении 1 и "a". А хотелось
бы взглянуть на этого "сферического единорога в вакууме"
2. Достаточно много программистов дали ответы, несильно отличающиеся от ответов
большинства.

## Вопросы о питоне
### Мнение о скорости питона
```{r} 
result$simple_plots$slow_python
knitr::kable(result$simple_tables$slow_python)
```
*Выводы*:

1. Где-то внутри столбика "побыстрее бы" прячутся ленивые олимп-прогеры и 
дата-саентисты.
2. Около половины программистов вообще не парится
3. Доля терпил довольно высока.

### Отношение к изменяемости списков
```{r} 
result$simple_plots$list_mutable
knitr::kable(result$simple_tables$list_mutable)
```
*Выводы*:

1. С одной стороны, изменяемость списков (и прочих изменяемых коллекций) 
позволяет менять элементы без необходимости копирования всего списка.
2. Но с другой стороны, она вызывает геморроидальные боли при записи 
элементов якобы "разных" списков. Поэтому в данном случае, их всё равно 
приходится копировать.
3. Как бы там ни было, большинство ответов составил вариант "позитивно"

### Мнение о "сахарности" питона
```{r} 
result$simple_plots$sugar
knitr::kable(result$simple_tables$sugar)
```
*Выводы*:

1. Основная масса вполне довольна удобством методов питона. Конечно, ведь по 
сравнению с другими языками, это просто спаснение от соблюдения типизации и 
расстановки скобок и точек с запятой.
2. Четверть даже не потянула всей мощи Великого Третьего Змея.
3. Количество диабетиков и сладкоежек составило ~ 11% от опрошенных

### Недовольство питоном
```{r} 
result$simple_plots$python_discontent
```
*Выводы*:

1. 

## Вопросы о использовании синтаскического сахара
### Использование тернарного модуля
```{r} 
result$simple_plots$ternar_module
knitr::kable(result$simple_tables$ternar_module)
```
*Выводы*:

1. 

### Использование списочных выражений
```{r} 
result$simple_plots$list_expressions
knitr::kable(result$simple_tables$list_expressions)
```
*Выводы*:

1. 

### Использование шаблонов проетирования
```{r} 
result$simple_plots$patterns
knitr::kable(result$simple_tables$patterns)
```
*Выводы*:

1. 

### Использование синтаксического сахара
```{r} 
result$simple_plots$sugar_using
```
*Выводы*:

1. 

## Вопросы о сферах программирования
### Мобильная или десктоп разработка?
```{r} 
result$simple_plots$mobile_desctop
knitr::kable(result$simple_tables$mobile_desctop)
```
*Выводы*:

1. 

### Необходимость веба
```{r} 
result$simple_plots$web
knitr::kable(result$simple_tables$web)
```
*Выводы*:

1. 

### Бек или фронт энд?
```{r} 
result$simple_plots$back_front_end
knitr::kable(result$simple_tables$back_front_end)
```
*Выводы*:

1. 

### Flask или Django?
```{r} 
result$simple_plots$flask_django
knitr::kable(result$simple_tables$flask_django)
```
*Выводы*:

1. 

### Использование веба
```{r} 
result$simple_plots$web_using
```
*Выводы*:

1. 
